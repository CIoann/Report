\chapter{Processor Extensions}\label{Processor extensions}

Coarsely, an RTOS offers services of three kinds: CPU allocation, memory allocation, and intra-task communication. In order to offer these functionalities, which allow to furnish a computational model more complex than the fixed allocation of a task to a processor, the underlying hardware should implement mechanisms such as interrupts and memory protection. This is the reason why the Patmos processor described in Chapter \ref{The Patmos processor} has been extended with:

\begin{itemize}
	\item Interrupts
	\item Stack cache manipulation instructions
\end{itemize}

Other extensions, e.g., for memory protection, have been discussed and investigated. However, since their implementation was not mandatory for the OS to work they have not been realized yet:

\begin{itemize}
	\item Address range checks
	\item Supervisor mode and cache invalidation
\end{itemize}

\section{Interrupts}\label{sec:interrupts}

Interrupts are used to stop the current flow of control jumping to a dedicated Interrupt Service Routine (ISR) in order to react to external events~\cite{t-crest:d5.1}. Interrupts are widely adopted by modern architectures for several reasons; interrupts are used, for instance, to implement preemptive scheduling mechanisms, start periodic operations, or react to I/O events.\\ When a context switch happens, processor's state must be stored to memory in order to restore it at a later point.\\

Different solutions for time and interrupt management have been developed. PPC 750 model~\cite{PPC750:2012} offers a long-period timer called \texttt{TB - Time Base}. The \texttt{TB} is a 64-bit structure that consists of two 32-bit registers: time base upper (\texttt{TBU}) and time base lower (\texttt{TBL}). PPC 750 offers also a decrementer register \texttt{DEC}. The \texttt{DEC} register is a 32-bit decrementing register used to fire a \textit{decrementer interrupt} at a programmable delay. \texttt{DEC} has the same update frequency as the time base. When a decrementer interrupt is fired, instruction fetching resumes at a specified position in main memory where an \texttt{ISR} (Interrupt Service Routine) has been previously set.\\ 
A more complete solution is AM17x/AM18x ARM Microprocessor which offers a Real-Time Clock (RTC)~\cite{AM17x/AM18x:2011}. Several RTC registers are mapped into memory: \texttt{SECOND}, \texttt{MINUTE}, \texttt{HOUR}, \texttt{DAY}, \texttt{MONTH}, \texttt{YEAR}, some memory-mapped registers can be used to set up interrupt intervals: \texttt{ALARMSECOND}, \texttt{ALARMMINUTE}, \texttt{ALARMHOUR}, \texttt{ALARMDAY}, \texttt{ALARMMONTH}, \texttt{ALARMYEAR}.\\

The Patmos RTC offers different registers mapped to the local memory, which allow to read/write different values.

\begin{table}[!h]
\centering
\begin{tabular}{l|l}
\textbf{Address} & \textbf{I/O Device}\\
\toprule
\texttt{0xf0000300} & Clock cycles (lower 32 bits)\\
\texttt{0xf0000304} & Clock cycles (upper 32 bits)\\
\texttt{0xf0000308} & Time in microseconds (lower 32 bits)\\
\texttt{0xf000030C} & Time in microseconds (upper 32 bits)\\
\texttt{0xf0000310} & Interrupt interval\\
\texttt{0xf0000314} & ISR address\\
\bottomrule
\end{tabular}
\caption{Memory mapped RTC registers\label{tab:rtc}}
\end{table}

The clock cycles counter is a 64 bits value updated every CPU cycle. The time in microseconds (64 bits) value is incremented every microsecond. The interrupt interval value is decremented every CPU cycle and when it reaches 0 an interrupt is fired and it is set back to
its maximum value (both upper and lower registers to \texttt{0xfffffff}). The ISR address value can be used to set the address of the interrupt service routine which has to be called after an interval interrupt.

\subsection{Simulator Implementation}

In order to implement the interrupts mechanism (the memory mapped RTC and the ISR calls) the Patmos simulator (whose architecture is described in Appendix \ref{Software simulator of Patmos}) has been extended. A memory mapped resource has been added mapping the register of the RTC as shown in table \ref{tab:rtc}. Given the architecture explained in appendix \ref{Software simulator of Patmos} a new class called \texttt{mm\_rtc} has been created extending the base class \texttt{mapped\_device}, this class makes available the addresses in table \ref{tab:rtc} and allows to access the RTC registers. In order to access RTC registers the \texttt{mm\_rtc} class contains a field referencing an object of another class which actually implements the RTC functionalities (\texttt{rtc\_t} class).\\

The \texttt{rtc\_t} class holds a value for each register: clock cycles, time in microseconds, interrupt interval and ISR address and publishes methods to read and write those values. Moreover the \texttt{rtc\_t} class has a method to notify the RTC that a cycle has passed, this method is called \texttt{tick}.\\

A single RTC object is created as the simulation starts and is contained in the class \texttt{simulator\_t}, at every simulator cycle the \texttt{tick} method is called on the \texttt{rtc\_t} object. Since the software simulator cycle can not execute with a guaranteed frequency the \texttt{tick} method increments by one both the clock cycle counter and the time in microseconds register; this method is also responsible for decrementing the interrupt interval value. The extended architecture is shown in figure \ref{simulator_RTC_class_diagram}.

	\begin{figure}[!ht]
		\begin{center}
		\makebox[\linewidth]{\includegraphics[scale=0.9]{figures/simulator_RTC_class_diagram.pdf}}
		\end{center}
		\caption{Class diagram for the RTC's simulator extension}
		\label{simulator_RTC_class_diagram}
	\end{figure}

The class \texttt{interrupt\_handler\_t} realizes the connection between the components firing interrupts and the simulation core, responsible of actually handling those interrupts. When an interrupt is fired it is appended to a collection of interrupt describers in the class \texttt{interrupt\_handler\_t}. At every cycle the simulator checks for interrupts pending in the \texttt{interrupt\_handler\_t} object, the handling code is shown in listing \ref{lst:interrupt_handling}.\\

To handle the interrupts a new branch instruction has been defined, represented by the class \texttt{i\_intr\_t}, and it is inserted in the pipeline when a pending interrupt is detected. An \texttt{i\_intr\_t} instruction can not be decoded so it can not be used by the programmer. However, it can be executed by the simulator. An \texttt{i\_intr\_t} instruction is just like a branch instruction which jumps to the ISR address. After this instruction is added a special register (\texttt{s9}) is set to the return address (the \texttt{PC}). \texttt{interrupt\_handling} counter is set in order to remember that an interrupt instruction has been added and since it behaves like a branch bubble instructions must be added in the next cycles.\\

Particular attention must be placed into handling interrupts fired during the execution of branch instructions. As shown in Section \ref{sec:call and branch} branch instructions must be followed by \texttt{branch-delay slots}, during these slots the branch takes actually place. The execution of an interrupt instruction should be placed after those slots, but in case of loop it has to be placed before the branch instruction is executed again. Those are the reasons why if a branch instruction is decoded a counter is set in order to make the simulator aware that the next instructions have not to be interrupted.

\begin{lstlisting}[language=C, caption=Interrupt handling code added to the simulator main cycle, label=lst:interrupt_handling]
if (Interrupt_handler.interrupt_pending() && 
	branch_counter == 0 && 
	interrupt_handling == 0) 
{ 

	interrupt_t &interrupt = Interrupt_handler.get_interrupt();

	Pipeline[0][0] = instruction_data_t::mk_CFLb(*intr, p0, interrupt.Address);
	Pipeline[0][1] = instruction_data_t();

	// Handling interrupt, next CPU cycle no new instructions have to be decoded
    interrupt_handling = 3;

    // Store return from interrupt address
    SPR.set(s9, PC);
}
else 
{
	if (interrupt_handling > 0) 
	{
		// Putting more empty instructions
		Pipeline[0][0] = instruction_data_t();
		Pipeline[0][1] = instruction_data_t();
		interrupt_handling--;
	} else {
		// fetch the instruction word from the method cache.
		Method_cache.fetch(PC, iw);
		iw_size = Decoder.decode(iw,  Pipeline[0]);

		// provide next program counter value
		if(Pipeline[0][0].I->is_flow_control())
			branch_counter = 2;
		else if (branch_counter)
			branch_counter--;

		nPC = PC + iw_size*4;
	}
}
\end{lstlisting}

\section{Stack Cache Manipulation}

As noted in Section \ref{sec:stack cache} the stack cache is handled using three simple instructions:
\begin{itemize}
	\item \texttt{sres} 
	\item \texttt{sens}
	\item \texttt{sfree}
\end{itemize}

Any of those instructions takes an immediate parameter. In order to support context switching more complex ways of manipulating the stack cache are needed. Section \ref{sec:stack cache} shows how the type of data a stack cache contains allows not to implement a write-back policy; this may lead to inconsistencies: the stack cache can contain data not persisted in the actual stack. When a context switch happens there is the need not only to save registers state but the state of the stack cache needs to be saved for the current executing thread and not only registers state of the next executing thread but even its stack cache has to be restored. Figure \ref{stack_cache_inconsistency} shows how the stack cache can have a more updated state than the actual stack and the values of the pointers \texttt{ss} (stack spill address) and \texttt{st} (stack pointer).


	\begin{figure}[!ht]
		\begin{center}
		\makebox[\linewidth]{\includegraphics[scale=0.9]{figures/stack_cache_inconsistency.pdf}}
		\end{center}
		\caption{Possible state of the stack cache and the actual stack during the execution}
		\label{stack_cache_inconsistency}
	\end{figure}

When a context switch occurs the stack cache state may be the one depicted in figure \ref{stack_cache_inconsistency}. In this case stack cache content has to be saved to the main memory since it has not been saved yet and the new executing thread may be changing the stack cache itself. None of the three previously defined instructions allows writing back a specific amount of stack cache, so a new instruction, \texttt{sspill} has been introduced.\\ 

\texttt{sspill} instruction takes an immediate or a register parameter and saves the specified amount of stack cache in main memory downward, starting from address \texttt{ss}. This means that, starting from the configuration in figure \ref{stack_cache_inconsistency} and supposing to execute the instructions in listing \ref{lst:stack_cache_spill}, the stack state will be just like the one in figure \ref{stack_cache_spilled}.

\begin{lstlisting}[caption=Code for spilling to main memory the cached stack, label=lst:stack_cache_spill]
// Computing the size of the cached stack
mfs		r5	= ss
mfs		r6	= st
sub 	r27 = r5, r6
// Spilling the computed size to main memory
sspill	r27
\end{lstlisting}

	\begin{figure}[!ht]
		\begin{center}
		\makebox[\linewidth]{\includegraphics[scale=0.9]{figures/stack_cache_spilled.pdf}}
		\end{center}
		\caption{Stack cache and memory state after executing instructions \ref{lst:stack_cache_spill}}
		\label{stack_cache_spilled}
	\end{figure}

On a context switch the current executing thread must be saved but the re-entering thread's context must also be restored and this means restoring the stack cache state too. Even in this situation none of the three previously defined instructions can be helpful. What is needed is an ensure instruction capable of checking and eventually loading a dynamic amount of stack. A new \texttt{sens} instruction, accepting a register parameter has been defined. Its behaviour is just like the immediate ensure and is shown in figure \ref{stack_cache_restore}.\\

Immediately after saving the current executing thread's stack cache the elected thread's stack cache state needs to be restored. To restore the stack cache the \texttt{sens} instruction is used in its register version. This instruction takes a register as a parameter and ensures that the specified amount from the top of the stack is contained in the stack cache. To restore the previous state the size of the stack previously contained in the cache has to be known, this value can be computed as \texttt{old\_ss - st}.

\begin{figure}[!ht]
        \centering
        \begin{subfigure}[b]{\textwidth}
                \centering
                \includegraphics[width=\textwidth]{figures/stack_cache_restore_1.pdf}
                \caption{State of a newly elected thread's stack and stack cache before \texttt{sens}}
        \end{subfigure}%
	
		\vspace{1cm}

        \begin{subfigure}[b]{\textwidth}
                \centering
                \includegraphics[width=\textwidth]{figures/stack_cache_restore_2.pdf}
                \caption{State of the stack cache after \texttt{sens}}
        \end{subfigure}
        \caption{Changes to the stack cache after the execution of \texttt{sens rX} where \texttt{rX} contains the value \texttt{old\_ss - st}}\label{stack_cache_restore}
\end{figure}

\section{Memory Protection}\label{sec:address range checks}

A composable operating system has to offer timing and spatial separation between processes. Moreover, in modern real-time systems it is common to have processes of different integrity levels executing on the same processor, this makes the need of memory protection arise. In order to have a time-composable system and to guarantee memory protection between different integrity levels spatial separation is necessary.\\ Several ways of providing spatial separation exist, most of them rely on memory virtualization and the usage of a Memory Management Unit (\texttt{MMU}). Modern processors implement a \texttt{MMU} which is responsible for translating virtual to physical addresses in order to make processes access their own memory and avoid forbidden accesses. Commercial \texttt{MMUs} are often tuned on the average case, they make use of a software managed address cache called Translation Look-aside Buffer (TLB). A \texttt{TLB} is a fixed size software managed set of \texttt{PTE} (Page Table Entries), it is searched through a virtual address and allows to translate it to a physical address.\\

\texttt{TLB} lookups, just like normal caches lookups, can result in a hit or a miss. A successful lookup (hit) has a bounded WCET. On the other hand the miss WCET is really hard to compute since a complex pagetable data structure stored in memory has to be consulted.\\

Different solutions are adopted by modern real-time operating systems in the field of memory separation and protection, always trying to avoid the complexity of virtual address translation.~\cite{10.1109/EMRTS.2001.934028} argues that two main approaches can be carried on: 

\begin{enumerate}
	\item Using the \texttt{MMU} translation system as it is
	\item Disabling all the memory translation features and running all the processes in the same address space
\end{enumerate}

\os natively targets the PowerPC architecture and makes use of virtual address translation. In the case of Patmos no virtual memory support and address translation was available. Because of the lack of these functionalities all processes run in the same address space.

Often real-time operating system exploit only the permission functionalities of a \texttt{MMU}, avoiding the virtual-to-physical address translation, to provide memory protection (\cite{Simpson:2005:SPE:1086297.1086307} and~\cite{Memprot:2004}).
Using only some \texttt{MMU}'s functionalities, as shown in ~\cite{10.1109/EMRTS.2001.934028}, can guarantee spatial separation maintaining the system analyzable. Processors providing a software programmable \texttt{TLB} (that is: with explicit \texttt{PTEs} load, such as PowerPC) allow to translate a certain range of virtual addresses without incurring in a \texttt{TLB} miss. If the virtual addresses of all pagetables are limited to this range the worst case execution time for a translation to physical address is limited by the time needed to search the \texttt{TLB}.\\ In the future Patmos processor may be extended with address range checks in order to have spatial separation between processes.

\section{Explicit Supervisor Mode and Cache Invalidation}\label{sec:explicit supervisor mode and cache invalidation}

Modern processors offer a way to distinguish between at least two execution modes: user and supervisor mode. Supervisor mode allows to execute all instruction, even privileged ones, access a different address space and manipulate memory management hardware. The existence of these modes helps protecting the operating system data structures from corruption attempts made by user code. When supervisor mode is not active the CPU will not allow to access privileged memory areas or execute privileged instructions.\\

The switch between execution modes may be expensive in terms of computing time: when switching from supervisor to user mode it is recommended to flush and invalidate the caches in order to make sure the user code can not access something it is not meant to. Switching to supervisor mode is usually done when executing context switches and system calls.\\

Different processors provide different ways of switching to supervisor mode.\\ PowerPC processors~\cite{PPCEnv:2005} have two levels of privilege: supervisor mode (used only by the operating system) and user mode (used by the operating system and application code). PowerPC architecture distinguishes between these two modes through the Machine State Register (\texttt{MSR}), a special purpose register holding processor's configuration setup: the \texttt{PR} bit of the \texttt{MSR} indicates the privilege level as follows:
\begin{itemize}
	\item \texttt{MSR[PR]=1}: user mode
	\item \texttt{MSR[PR]=0}: supervisor mode
\end{itemize}

\texttt{MSR[PR]} is set to 0 (supervisor) every time an interrupt happens and an \texttt{ISR} is executed. The user code can explicitly switch to supervisor mode through the \texttt{sc} instruction which causes a System Call exception and the execution of the system call \texttt{ISR}.\\ An ARM processor~\cite{ARMmig:2012} has 7 different privilege levels:

\begin{itemize}
	\item \texttt{SVC} (supervisor): entered when a system call instruction (\texttt{SVC}) is executed
	\item \texttt{FIQ}: high priority interrupts mode
	\item \texttt{IRQ}: normal priority interrupts mode
	\item \texttt{Abort}: entered when memory protection is violated
	\item \texttt{Undef}: entered when undefined instructions are used
	\item \texttt{System}: just like \texttt{SVC} mode but working with user mode registers
	\item \texttt{User}
\end{itemize}

The privilege level is stored in a field in the Current Program Status Register (\texttt{CPSR}), a special register holding both \texttt{ALU}'s and processor's status. Modification to the priority level can be done by directly manipulating the \texttt{CPSR}. In order to access the OS services user code can explicitly switch to supervisor mode through the system call instruction (\texttt{SVC}).\\

As a future possible extension, the Patmos processor might be added a syscall instruction dedicated to switching to supervisor mode through an interrupt and defining a special register holding the machine state, including at least one bit to distinguish between user and supervisor mode.\\

Another possible extension may be the previously mentioned cache flushing and invalidation. Invalidating the caches when a context switch happens is a common practice in avionics when a partition switch happens since partitions do not have shared memory. Moreover cache invalidation can be useful to avoid interference between the current executing thread and the next elected one when preemption is enabled.\\

Patmos provides three kinds of caches: stack, method, and data cache. The stack cache has enough instruction to be handled precisely by the operating system, storing and restoring its content without any need for invalidation. 






