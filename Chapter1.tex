\chapter{Introduction}

Programming is a really complex procedure and requires a great amount of human memory. Although modern program development environments have begun to recognize the complexity and the memory requirements of programmers, none of these tools are able to take into account the programmers' cognition. \todo{Chris Parnin and Spencer Rugaber. Programmer information needs after memory failure. In ICPC ’12: Proceedings of the 20 Interaction Conference on Program Comprehension, pages 123–132, 2012.
} Therefore the process of software development doesn't feel any better than it did a generation ago. Previous research focuses on understanding how developers operate to complete their jobs: how they keep their tasks structured, the strategies they apply, the tools they use


Several studies has shown that, despite the usefulness of provided tools and capabilities to perform tasks such as navigating among classes and methods, continuous compilation, code refactoring and integrated debugging, IDEs usually tend to overload de- velopers resulting a chaotic state. In other words, commonly developers spend time shifting between several artifacts of the working environment in order to reach their goal, and this repeated process increases the complexity of identifying the relevant information to solve their assignment. 

Yet researchers pointed out certain aspects of the problem still the workflow and the way a programmer might think at a particular moments is still a mystery.

in order to improve the environments available we have although to understand these aspects.

ides aim to help the user however often they create a general chaos with all the navigation the studies of .. and the Cognition studies and models strategies top down bottom up, 

previous research of understanding the workflow of a developer is done by ... 

previous research of attempting to extracct user activities from \gls{ide} ... 

Abstract—Developers use the Integrated Development Environ-
ment (IDE) to develop a system at hand, by reading, understand-
ing, and writing its source code. They do so by exploiting the tools

and facilities provided by the IDE. This also allows them to build
a mental model of the system to perform informed changes. It is
however not clear how and when developers use which facility
and tool, and to what extent the current services o↵ered by the
IDE appropriately support the navigation.
We present an approach to visualize the activities of developers
within the IDE, implemented in a tool: DFlow. DFlow records
all IDE interactions that occur during a development session and



By better understanding actual work practices, looking for patterns in them, and in performing empirical studies based on this knowledge, we can better address how to create the next generation of supporting tools for software developers.

Previous research of understanding how software developers do their jobs has focused mainly on studies of programmer cognition and work practices. Cognition studies try to ex- plore the cognitive models, strategies, and patterns used by developers performing program comprehension. Mostly based on laboratory experiments, these studies have shown that programmers apply multiple comprehension strategies, such as top-down [Bro77], bottom- up [Pen87] , and integrated [vMV95], and also that patterns in the code, such as beacons [Bro83, GC91], plays an important role in comprehension. These findings have guided the design of some research development tools (e.g., Shrimp [SBM01]) in supporting program comprehension. The study of developer work practices, on the other hand, focuses on a big picture of industrial developers working in the context of realistic development tasks. Sur- veys, diaries, interviews, and other methods have led to several surprising insights about work practice; for example, Singer et al. found that developers spend significant effort on
1
searching for code elsewhere in the system that relates in some way to the code they are working on [SLVN97]. Seaman found that the information sources that developers rely on most are source code, colleagues, and various development artifact repositories [Sea02]. These findings suggest that supporting improved information searching, interruption man- agement, and repository mining can be helpful to programmers.
%In this chapter we introduce some key aspects of Real-Time Systems (RTS), starting from the computational model. We then discuss \textit{timing analysis} and Worst-Case Execution Time (WCET) calculation. After that we introduce \textit{time-composability} and how important that property is. In Section the role of a Real-Time Operating System (RTOS) is described and some examples are presented. In the end the T-CREST project and platform are briefly described.


\section{The problem}

Although, the mentioned findings are a bit irrelevant because we are awesome

A fine-grained understanding of developers 
a fine-grained understanding of industrial programmers working in an industrial context remains limited. Cognitive studies often involve student programmers working on small problems. It is hard to generalize from such small-scale studies to industrial software development practice, where developers typically have a much larger code base and more complicated tasks to consider, and where they will be ultimately be held accountable for their decisions. Detecting high-level comprehension strategies has been the main focus of cognitive studies. But detailed work patterns — such as what artifacts are usually used for solving certain typical sub-tasks, and what relationships exist between those artifacts — remain mostly unexplored. Moreover, the relation between programmers’ work and contextual factors is poorly understood. As shown in Figure 1.1, driven by maintenance tasks, programmers interact with artifacts of a software system using tools in the work domain. 

Tasks may largely determine which parts of the software system are relevant, but other factors in software development, such as the expertise level of programmer, the design of the software system, the features of the tool, and interruptions during tasks, may all affect programmer’s detailed work pattern. To understand how industrial software developers perform their job — and how we can help them do better — we should not ignore these contextual factors.

\section{The approach}
\section{Integrated Development Environment}
	%\todo{list available and discuss}
	%\todo{paragraph why we choose eclipse}
	%\todo{programmer workflow within IDE}
\section{Structure of thesis}
