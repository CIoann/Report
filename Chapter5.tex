\chapter{\os Extensions}

The \os operating system has been extended to support the Patmos architecture. The porting of the operating system has been carried on following an incremental development technique. Following the structure presented in Chapter \ref{sec:the operating system} the incremental development followed the operating system layers order:

\begin{enumerate}
	\item \textbf{kernel}: the kernel layer, divided itself in two layers, examined in the appearing order: \textbf{arch} and \textbf{core}
	\item \textbf{ARINC API} and \textbf{library}
\end{enumerate}

The incremental development technique allowed to start from the most architectural-dependent layer, understanding and modifying small functions which form together the core functionalities of the operating system. Moving to the next layer (the \textbf{core} one) all the underneath dependencies were already ported to the Patmos architecture and this let the development be more focused on core services of the operating system.\\

A common risk when porting an existing operating system to a different architecture is concentrating too much on the architectural-dependent code. This attitude may lead to miss the perspective on the system as a whole. When working with notably different architectures, like Patmos, the porting is not only an assembly-translation but the core functionalities of an OS have to be inspected paying attention on identifying unnecessary operations and possible optimizations.\\

In the following the operating system's changes are analyzed as incrementally as possible. Some functionalities that are inherently cross layer (like context switching) are however explained in a dedicated section in order to achieve more clarity.

\section{Architectural Changes}

As shown is Section \ref{sec:build chain} the architectural layer of the operating system is compiled in a single link object (\texttt{arch.lo}). Since this layer is mainly made of assembly files not much code can be reused and for this reason a new directory named \texttt{arch/patmos} has been created containing all the Patmos-dependent code which is then compiled in \texttt{arch.lo}.

\subsection{Clock} 

In Section \ref{sec:interrupts} the new memory mapped real-time clock is presented. The RTC's registers are mapped to the local memory and therefore have to be accessed through local memory instructions.\\
A header file has been created defining a number of pre-compilation directives allowing to read and write RTC memory mapped registers, see listing \ref{lst:rtc.h} for details.

\begin{lstlisting}[language=C, caption=rtc.h contains directives to read and write memory mapped RTC registers, label=lst:rtc.h]
#define _IODEV __attribute__((address_space(1)))

typedef _IODEV unsigned int volatile * const _iodev_ptr_t;

#define __PATMOS_RTC_CYCLE_LOW_ADDR (0xF0000300)

#define __PATMOS_RTC_CYCLE_UP_ADDR (0xF0000304)

#define __PATMOS_RTC_TIME_LOW_ADDR (0xF0000308)

#define __PATMOS_RTC_TIME_UP_ADDR (0xF000030C)

#define __PATMOS_RTC_INTERVAL_ADDR (0xF0000310)

#define __PATMOS_RTC_ISR_ADDR (0xF0000314)

#define __PATMOS_RTC_RD_CYCLE_LOW(res) res = *((_iodev_ptr_t)__PATMOS_RTC_CYCLE_LOW_ADDR);

#define __PATMOS_RTC_RD_CYCLE_UP(res) res = *((_iodev_ptr_t)__PATMOS_RTC_CYCLE_UP_ADDR);

#define __PATMOS_RTC_RD_TIME_LOW(res) res = *((_iodev_ptr_t)__PATMOS_RTC_TIME_LOW_ADDR);

#define __PATMOS_RTC_RD_TIME_UP(res) res = *((_iodev_ptr_t)__PATMOS_RTC_TIME_UP_ADDR);

#define __PATMOS_RTC_WR_CYCLE_LOW(val) *((_iodev_ptr_t)__PATMOS_RTC_CYCLE_LOW_ADDR) = val;

#define __PATMOS_RTC_WR_CYCLE_UP(val) *((_iodev_ptr_t)__PATMOS_RTC_CYCLE_UP_ADDR) = val;

#define __PATMOS_RTC_WR_INTERVAL(interval) *((_iodev_ptr_t)__PATMOS_RTC_INTERVAL_ADDR) = interval;

#define __PATMOS_RTC_WR_ISR(address) *((_iodev_ptr_t)__PATMOS_RTC_ISR_ADDR) = address;
\end{lstlisting}

Some of the directives define addresses to the local memory:

\begin{itemize}
	\item \texttt{\_IODEV}: redefines \texttt{\_\_attribute\_\_((address\allowbreak\_space\allowbreak(1)))} which allows to access different address spaces, in this case 1 indicates the local memory
	\item \texttt{\_iodev\_ptr\_t}: type for a constant pointer to the local memory, allows to access memory mapped registers
	\item \texttt{\_\_PATMOS\_RTC\_CYCLE\_LOW\_ADDR}: address for the lower 32 bits of the cycle counter
	\item \texttt{\_\_PATMOS\_RTC\_CYCLE\_UP\_ADDR}: address for the upper 32 bits of the cycle counter
	\item \texttt{\_\_PATMOS\_RTC\_TIME\_LOW\_ADDR}: address for the lower 32 bits of the time in microseconds register
	\item \texttt{\_\_PATMOS\_RTC\_TIME\_UP\_ADDR}: address for the upper 32 bits of the time in microseconds register
	\item \texttt{\_\_PATMOS\_RTC\_INTERVAL\_ADDR}: address for the interval register
	\item \texttt{\_\_PATMOS\_RTC\_ISR\_ADDR}: address for the memory mapped register of the ISR's address
\end{itemize}

Other directives enable reading memory-mapped registers:

\begin{itemize}
	\item  \texttt{\_\_PATMOS\_RTC\_RD\_CYCLE\_UP} and \texttt{\_\_PATMOS\_RTC\_RD\_CYCLE\_LOW}: read upper and lower 32 bits of the cycle counter
	\item \texttt{\_\_PATMOS\_RTC\_RD\_TIME\_UP} and \texttt{\_\_PATMOS\_RTC\_RD\_TIME\_LOW}: read upper and lower 32 bits of the time in microseconds
\end{itemize}

And some directives allow to write values to the memory-mapped registers:

\begin{itemize}
	\item \texttt{\_\_PATMOS\_RTC\_WR\_CYCLE\_UP} and \texttt{\_\_PATMOS\_RTC\_WR\_CYCLE\_LOW}: write upper and lower 32 bits of the cycle counter
	\item \texttt{\_\_PATMOS\_RTC\_WR\_INTERVAL}: writes to the memory-mapped interval register, the value is supposed to be a clock cycles number
	\item \texttt{\_\_PATMOS\_RTC\_WR\_ISR}: writes to the memory-mapped register holding the interval ISR address
\end{itemize}

The above directives are used in the time management functions of the operating system's architectural layer. These functions realize basic operative system's services such as: reading the time base, writing the time base, and setting the interrupt interval. 

\subsection{Thread's Context}\label{sec:thread context}

The PowerPC architecture provides three types of registers~\cite{PPCEABI:1998}:
\begin{itemize}
	\item \textit{volatile}: functions may modify these registers. The content of volatile register has not to be preserved
	\item \textit{non-volatile}: functions must preserve their value. If a function modifies a non-volatile register it has to restore the previous content before returning
	\item \textit{dedicated}: these registers have to be used only for their specific purpose
\end{itemize}

The original operating system defined two data structures holding a thread's context: \texttt{volatile\_context\_t} and \texttt{context\_t}. The structures holding the context were originally allocated on the top of the thread's stack. The union of the two data structures is a multiple of a quadword since, according to the PowerPC EABI~\cite{PPCEABI:1998}, a stack frame has to be quadword aligned.\\

The thread context in Patmos is much simpler for several reasons:
\begin{itemize}
	\item In Patmos there's no particular need to have different data structures for \textit{volatile} (\textit{caller-saved}) and \textit{non-volatile} (\textit{callee-saved}) registers
	\item The thread context in Patmos is more compact: as presented in Section \ref{sec:registers} there are only 32 general purpose registers (32 bit), 16 special purpose registers (32 bit) and 8 predicate registers (1 bit). No floating point registers have to be saved
	\item Patmos stack do not impose any particular alignment to stack frames; furthermore, in Patmos thread's context is not placed on the stack
\end{itemize}

That said, the data structure holding the context is presented in listing \ref{lst:patmos context}.

\begin{lstlisting}[language=C, caption=C structure holding Patmos context, label=lst:patmos context]
typedef struct
{
	uint32_t r1;	/*	0	*/
	uint32_t r2;
	uint32_t r3;	/*	8	*/
	uint32_t r4;
	uint32_t r5;	/*	16	*/
	uint32_t r6;
	uint32_t r7;	/*	24	*/
	uint32_t r8;
	uint32_t r9;	/*	32	*/
	uint32_t r10;
	uint32_t r11;	/*	40	*/
	uint32_t r12;
	uint32_t r13;	/*	48	*/
	uint32_t r14;
	uint32_t r15;	/*	56	*/
	uint32_t r16;
	uint32_t r17;	/*	64	*/
	uint32_t r18;
	uint32_t r19;	/*	72	*/
	uint32_t r20;
	uint32_t r21;	/*	80	*/	
	uint32_t r22;
	uint32_t r23;	/*	88	*/	
	uint32_t r24;
	uint32_t r25;	/*	96	*/
	uint32_t r26;
	uint32_t r27;	/*	104	*/
	uint32_t r28;
	uint32_t r29;	/*	112	*/	
	uint32_t r30;
	uint32_t r31;	/*	120	*/

	uint32_t s0;
	uint32_t s1;	/*	128	*/
	uint32_t s2;
	uint32_t s3;	/*	136	*/
	uint32_t s4;
	uint32_t s5;	/*	144	*/
	uint32_t s6;
	uint32_t s7;	/*	152	*/
	uint32_t s8;
	uint32_t s9;	/*	160	*/
	uint32_t s10;
	uint32_t s11;	/*	168	*/
	uint32_t s12;
	uint32_t s13;	/*	176	*/
	uint32_t s14;
	uint32_t s15;	/*	184	*/

	uint32_t ssize; /*	188	*/
} context_t;
\end{lstlisting}

The Patmos context contains general-purpose caller-saved (scratch) registers (\texttt{r1-r19}), general-purpose callee-saved registers (\texttt{r20-r31}) and special purpose registers (\texttt{s0-s15}). Since \texttt{r0} always contains 0 by convention there's no need to save in in the context. In the Patmos processor the context of a thread is not only made of registers but even the stack cache status has to be taken into account. This is the reason for the field \texttt{ssize} in the context data structure: it holds the amount of thread's stack stored in the cache and it is used to restore the stack cache status after a context switch, details in Section \ref{sec:context switch}.

\subsection{Memory Management}

The original operating system made use of PowerPC memory virtualization functionalities. As stated in Section \ref{sec:address range checks} Patmos has no virtual memory capabilities so a new memory allocation mechanism has to be thought. In \ref{sec:address range checks} address range checks have been presented as a possible extension for the Patmos processor, keeping this in mind the memory could be divided in parts each of which could be assigned a different privilege level. According to this a thread's context is no longer stored on the top of the thread's stack but a dedicated OS structure has been allocated in memory, holding all the user application threads contexts. Using the memory protection technique this array of contexts could be stored in the protected memory area with kernel level privilege.\\

As presented in Chapter \ref{The Patmos processor}, Patmos not only supports a normal and cached stack but even a shadow stack dedicated to hold aliased data. Therefore each thread must benefit from allocated memory for both caches. Before inspecting the memory layout created by the operating system it is worth to take a look to how the system is inited and the partitions are created. First of all the kernel is booted using a kernel stack (cached) and a kernel shadow stack. During the booting phase each partition is loaded into memory and for each partition a \textit{main thread} is created, responsible for starting all the partition's processes. Each partition's \textit{main thread} owns a cached stack and a shadow stack. Each ARINC process is mapped to a thread and so is granted space for both stacks. To sum things up the memory to be allocated is:

\begin{itemize}
	\item A cached stack and a shadow stack for the kernel
	\item A cached stack and a shadow stack for each partition's (\textit{main thread})
	\item A cached stack and a shadow stack for each partition's process
\end{itemize}

The memory for the kernel's stack is placed in the \texttt{bss} section and two labels are defined in order to access this memory (see listing \ref{lst:kernel stacks labels}).

\begin{lstlisting}[language=C, caption=Assembly labels for the kernel's stacks, label=lst:kernel stacks labels]
	.section ".bss", "aw"
pok_shadow_stack:
		.space 8 * 1024
		.globl pok_shadow_stack_end
pok_shadow_stack_end:

pok_stack:
		.space 8 * 1024
		.globl pok_stack_end
pok_stack_end:
\end{lstlisting}

The two defined labels are used to initialize stack pointer's register (\texttt{st}), shadow stack pointer's register (\texttt{r29}) and the stack cache spill address (\texttt{ss}) in the entry point function of the operating system, indicated in listing \ref{lst:OS entry point}.

\begin{lstlisting}[language=C, caption=Assembly code for the entry point of the operating system, label=lst:OS entry point]
		.globl 		_pok_reset
		.type 		_pok_reset,@function
		.size 		_pok_reset, .Ltmp8-_pok_reset
		.fstart		_pok_reset, .Ltmp8-_pok_reset, 4
_pok_reset:
		li		$r1 				= pok_stack_end 
		li		$r2 				= pok_shadow_stack_end
		mov 	$r29 				= $r1
		mts 	$st  				= $r2
		mts 	$ss 				= $r2
		and 	$r0 				= $r0, 0x0

		brcf 	_pok_clear_bss
		nop
		nop	
		nop
.Ltmp8:
\end{lstlisting}

Through the kernel's linker script a label \texttt{\_end} is defined, identifying the end of the \texttt{bss} section. When the kernel is loaded into memory the \texttt{\_end} pointer indicates where to start allocating threads stacks. The space allocation works as follows:

\begin{enumerate}
	\item For each partition:
		\begin{enumerate}
			\item An amount of memory enough to hold all its threads stacks is allocated (\texttt{\_end} pointer is moved forward)
			\item From this memory some space is reserved for the \textit{main thread}'s stacks
		\end{enumerate}
	\item For each partition's user thread:
		\begin{enumerate}
			\item Some space is reserved in the partition's memory for stack and shadow stack
			\item Some memory is allocated, starting from \texttt{\_end} pointer) to hold the thread's context
		\end{enumerate}
\end{enumerate} 

The size of the kernel stacks is set by default while the size of the user threads stacks can be configured through two directives, as shown in table \ref{tab:stack sizes}.

\begin{table}[!h]
\centering
\begin{tabular}{l|l}
\textbf{Directive} & \textbf{Value}\\
\toprule
\texttt{USER\_STACK\_SIZE} & Configurable by the user \\
\texttt{USER\_SHADOW\_STACK\_SIZE} & Configurable by the user \\
\texttt{KERNEL\_STACK\_SIZE} & 8192 \\
\texttt{KERNEL\_SHADOW\_STACK\_SIZE} & 8192 \\
\bottomrule
\end{tabular}
\caption{Stack sizes for user and kernel threads}
\label{tab:stack sizes}
\end{table}

Threads stacks are placed in partition's memory starting from its bottom, first the cached stack is placed and then the shadow stack. The memory layout created by the operating system follows the structure depicted in figure \ref{fig:memory layout}.

	\begin{figure}[!ht]
		\begin{center}
		\makebox[\linewidth]{\includegraphics[scale=0.83]{figures/memory_layout.pdf}}
		\end{center}
		\caption{Memory layout created by the operating system}
		\label{fig:memory layout}
	\end{figure}

\section{Core Changes}

Some of the changes made to the architectural layer are reflected to the core layer. The core layer of the kernel is compiled into a library object \texttt{core.lo}, as stated in \ref{sec:build chain}. Since most of the code of this layer did not change, it made no sense to create different directories for each architecture, therefore to implement the following changes two pre-compilation directives are used: \texttt{POK\_ARCH\_PPC} (indicates that the kernel is being compiled for PowerPC architecture) and \texttt{POK\_ARCH\_PATMOS} (indicates that the kernel is being compiled for Patmos architecture).

\subsection{Bootloader}

Section \ref{sec:build chain} showed how the partitions are compiled, archived together and then put in the kernel's executable. During the kernel's boot phase the original version of the operating system used to search the executable for the partitions code, the research was made exploiting an array of partition's sizes.\\

The partitions loading mechanism has been modified so as to make the system more flexible and extendable: when booting the OS calls the function \texttt{partition\_init} responsible for creating the data structures holding all partitions and for loading each partition into memory, the partitions are loaded from the \texttt{UART}.\\
The operating system expects a specific stream of data for each partition, the format of the partition's stream is shown in figure \ref{fig:partition stream format}.

	\begin{figure}[!ht]
		\begin{center}
		\makebox[\linewidth]{\includegraphics[scale=0.83]{figures/partition_stream_format.pdf}}
		\end{center}
		\caption{Format of the partition's stream expected by the operating system on the \texttt{UART}}
		\label{fig:partition stream format}
	\end{figure}

The loading of a partition, given a stream structured like in figure \ref{fig:partition stream format}, is made through two auxiliary functions: \texttt{read\_uint32} and \texttt{read\_data} which respectively load from the \texttt{UART} an unsigned integer and a specified amount of binary data, these functions are shown in listing \ref{lst:read int and data}; both return the number of read bytes.

\begin{lstlisting}[language=C, caption=Function to read an integer and a variable amount of data from the \texttt{UART}, label=lst:read int and data]
static uint32_t read_uint32(uint32_t* ptr)
{
  return uart_read((char*)(ptr), sizeof(uint32_t));
}

static uint32_t read_data(uint32_t size, char* ptr)
{
  return uart_read(ptr, size);
}
\end{lstlisting}

A partition is loaded through the function \texttt{load\_partition}. First of all the partition entry and the number of segments are read through the function \texttt{read\_int}. Then for each segment address and size are read through \texttt{read\_int}, after this an amount of data of the specified size is read using \texttt{read\_data}. \texttt{load\_partition}'s code can be seen in listing \ref{lst:load partition code}.

\begin{lstlisting}[language=C, caption=\texttt{load\_partition} code, label=lst:load partition code]
void pok_loader_load_partition (const uint32_t part_id, uint32_t *entry)
{
	uint32_t part_entry;
	uint32_t segments;

	if(read_uint32(&part_entry) != sizeof(uint32_t))
	{
		pok_partition_error (part_id, POK_ERROR_KIND_PARTITION_CONFIGURATION);
	}
	if(read_uint32(&segments) != sizeof(uint32_t))
	{
		pok_partition_error (part_id, POK_ERROR_KIND_PARTITION_CONFIGURATION);
	}

	unsigned int segment = 0;
	while (segment < segments) 
	{
		uint32_t segment_address;
		uint32_t segment_size;

		if (read_uint32(&segment_address) != sizeof(uint32_t))
		{
			pok_partition_error (part_id, POK_ERROR_KIND_PARTITION_CONFIGURATION);
		}
		if (read_uint32(&segment_size) != sizeof(uint32_t))
		{
			pok_partition_error (part_id, POK_ERROR_KIND_PARTITION_CONFIGURATION);
		}
		if (read_data(segment_size, (char*)segment_address) != segment_size) 
		{
			pok_partition_error (part_id, POK_ERROR_KIND_PARTITION_CONFIGURATION);
		}
		segment++;
	}
	*entry = part_entry;
}
\end{lstlisting}

The partition entry point is then set as the entry for the partition's main thread and partition's segments are loaded into memory at the specified addresses.

\subsubsection{elf2uart}\label{sec:elf2uart}

\texttt{elf2uart} is a small program written in order to stream a Patmos executable to the simulator \texttt{UART}. The Patmos simulator can be configured to take a text file to be used as an input for \texttt{UART} reads, so \texttt{elf2uart} takes two files as parameters: the Patmos executable and the \texttt{UART} file.\\ \texttt{elf2uart} uses \texttt{libelf} to inspect the executable file and performs the following operations:

\begin{itemize}
	\item Opens the executable file as a read file and the \texttt{UART} file as write file; lines 5 to 10 of listing \ref{lst:streamelf}
	\item Gets the ELF header; lines 21 to 23 of listing \ref{lst:streamelf}
	\item Gets the number of program's headers in the program's header table (\texttt{e\_phnum} field); lines 25 to 27 of listing \ref{lst:streamelf}
	\item Gets the file entry point (\texttt{e\_entry} field) from the ELF header and writes it to the \texttt{UART}; lines 29 to 32 of listing \ref{lst:streamelf}
	\item Computes the number of segments of type \texttt{PT\_LOAD}. That is, segments to be loaded into memory; lines 36 to 48 of listing \ref{lst:streamelf}
	\item For each segment:
		\begin{itemize}
			\item Segment address is written to the \texttt{UART}; lines 65 to 73 of listing \ref{lst:streamelf}
			\item Segment size is written to the \texttt{UART}; lines 65 to 73 of listing \ref{lst:streamelf}
			\item Segment data is written to the \texttt{UART}; lines 75 to 79 of listing \ref{lst:streamelf}
		\end{itemize}
\end{itemize}

The function responsible for streaming a partition to the \texttt{UART} can be seen in listing \ref{lst:streamelf}.

\begin{lstlisting}[language=C, caption=Functions to stream an \texttt{ELF} file to the \texttt{UART} file, label=lst:streamelf]
static void streamelf(const char* elf_filename, const char* uart_filename)
{
	elf_version(EV_CURRENT);

	int elf_file = open(elf_filename, O_RDONLY, 0);
	assert(elf_file > 0);

	FILE* uart_file;
	uart_file = fopen(uart_filename, "w");
	assert(uart_file);

	Elf *elf = elf_begin(elf_file, ELF_C_READ, NULL);
	assert(elf);

	Elf_Kind ek = elf_kind(elf);
	assert(ek == ELF_K_ELF);

	int ec = gelf_getclass(elf);
	assert(ec == ELFCLASS32);

	GElf_Ehdr hdr;
	GElf_Ehdr *tmphdr = gelf_getehdr(elf, &hdr);
	assert(tmphdr);

	size_t n, i;
	int ntmp = elf_getphdrnum(elf, &n);
	assert(ntmp == 0);

	uint32_t entry = hdr.e_entry;

	uint32_t big_entry = toBigEndian(entry);
	fwrite(&big_entry, 4, 1, uart_file);
  
	std::vector<GElf_Phdr> load_segments;

	for(i = 0; i < n; i++)
	{
	    GElf_Phdr phdr;
    	GElf_Phdr *phdrtmp = gelf_getphdr(elf, i, &phdr);
    	assert(phdrtmp);

    	if (phdr.p_type == PT_LOAD)
    	{
			load_segments.push_back(phdr);
		}
	}

	int segments_number = load_segments.size();

	uint32_t big_segments_number = toBigEndian(segments_number);
	fwrite(&big_segments_number, 4, 1, uart_file);

	for(std::vector<GElf_Phdr>::iterator it = load_segments.begin(); it != load_segments.end(); ++it) 
	{
		GElf_Phdr phdr = *it;
		assert(phdr.p_vaddr == phdr.p_paddr);
		assert(phdr.p_filesz <= phdr.p_memsz);

		char *buf = (char*)malloc(phdr.p_filesz);
		assert(buf);

		lseek(elf_file, phdr.p_offset, SEEK_SET);
		read(elf_file, buf, phdr.p_filesz);

		uint32_t start_offset = phdr.p_vaddr;
		uint32_t size = phdr.p_filesz;
		uint32_t total_size = phdr.p_memsz;

		uint32_t big_start_offset = toBigEndian(start_offset);
		uint32_t big_size = toBigEndian(size);

		fwrite(&big_start_offset, sizeof start_offset, 1, uart_file);
		fwrite(&big_size, sizeof size, 1, uart_file);
        
		int j;        
		for(j=0; j < size; j++)
		{
			fwrite(&(buf[j]), 1, 1, uart_file);
		}

		free(buf);
	}

	elf_end(elf);
	close(elf_file);
	fclose(uart_file);
}
\end{lstlisting}

If \texttt{elf2uart} is executed on a \textit{little-endian} architecture the read integers (sizes and addresses) are represented according to the \textit{little-endian} format. Patmos processor manipulates \textit{big-endian} data, so before streaming those integers to the \texttt{UART} they have to be converted to \textit{big-endian} using the function in listing \ref{lst:toBigEndian}.

\begin{lstlisting}[language=C, caption=Functions converting \textit{small-endian} integers to \textit{big-endian} integers, label=lst:toBigEndian]
static inline uint32_t toBigEndian(uint32_t value)
{
	return ((value & 0xFF000000) >> 24) | 
							((value & 0x00FF0000) >> 8) |
							((value & 0x0000FF00) << 8) |
							((value & 0xFF) << 24);
}
\end{lstlisting}

\section{Library Changes}

The ARINC and library layer allows the user code to call operating system services. This layer is not compiled with the kernel but guarantees access to kernel functionalities through the system call mechanisms. Since the services offered by the operating system to the user code did not change this layer remained almost the same apart from the way system calls are performed.

\subsection{System Calls Implementation}

A library layer allows to call kernel services from the user code. Clearly a way to jump safely to the kernel code must be provided. As stated in \ref{sec:explicit supervisor mode and cache invalidation} architectures like PowerPC and ARM provide a special instruction able to perform a system call using the interrupts mechanism. In the original version of the operating system the dedicated PowerPC \texttt{sc} instruction was used to implement all the system call functions presented in Section \ref{sec:core library}, see listing \ref{lst:PowerPC system call}.

\begin{lstlisting}[language=C, caption=PowerPC system call implementation, label=lst:PowerPC system call]
		  .globl pok_syscall2
		  .globl pok_syscall3
		  .globl pok_syscall4
		  .globl pok_syscall5
		  .globl pok_syscall6 
		  .globl pok_syscall7 
pok_syscall2:
pok_syscall3:
pok_syscall4:
pok_syscall5:
pok_syscall6:	
pok_syscall7:
		  sc
		  brl
\end{lstlisting}

The Patmos processor does not provide a system call instruction. A normal \texttt{call} instruction can not be used since kernel symbols are not available when compiling user code. A special convention has to be adopted between kernel and library layers. Two solutions have been investigated:

\begin{itemize}
	\item Placing each kernel service in a fixed and known location in memory, call it \texttt{serviceN\_addr}, with each library's system call performing a immediate call to this address (\texttt{call serviceN\_addr})
	\item Placing in a dedicated and known memory location a system call service routine used by all system calls and able to dispatch to the proper kernel service
\end{itemize}

Clearly, the first proposed technique would have result in an unrealistic and non-extensible system. The second solution, on the other hand, is more realistic and resembles the way system calls are handled when using interrupts.\\

To implement the second solution the \texttt{system\_call} function, shown in listing \ref{lst:system_call function}, is placed at location \texttt{0x900} in the \texttt{text} segment through the \texttt{.org 0x900 - 4} directive. As said in Section \ref{sec:method cache} each function's code is preceded by its size so, in order to place a method at location \texttt{0x900}, the \texttt{.org} directive has to consider the space dedicated to the function's size, this explains the given address of \texttt{0x900 - 4}.

\begin{lstlisting}[language=C, caption=Kernel \texttt{system\_call} function, label=lst:system_call function]
		.globl		system_call
		.type 		system_call,@function
		.size 		system_call, .Ltmp2-system_call
		.org		0x900 - 4
		.fstart		system_call, .Ltmp2-system_call, 4
system_call:
		sres	2
		sws		[1] = $r31
		sws		[0] = $r30

		li		$r30 = system_call
		call 	pok_arch_sc_int
		nop
		nop
		nop

		sens	2
		lws		$r31 = [1]
		lws		$r30 = [0]
		sfree	2
		ret		$r30, $r31
		nop
		nop
		mov		$r1 = $r0
.Ltmp2:
\end{lstlisting}

\texttt{pok\_arch\_sc\_int} is the function responsible for identifying the type of system call, retrieving all the parameters, and calling the proper function. \\

Through the linker script the kernel's \texttt{text} segment is placed at the address \texttt{0x1C0000}. When running the system the kernel's \texttt{system\_call} function is going to be located at the address \texttt{0x1C0900}. That said, library's system calls are implemented via explicit calls to \texttt{0x1C0900}, as shown in listing \ref{lst:libary system calls}.

\begin{lstlisting}[language=C, caption=Library's system call implementation, label=lst:libary system calls]
#define SYS_CALL_ADDR 	0x1C0900
#define NOT_USED(x) 	((void)(x))
uint32_t (*syscall)(void) = (uint32_t (*)(void)) SYS_CALL_ADDR;
pok_ret_t pok_syscall1  (pok_syscall_id_t syscall_id,
						uint32_t arg1)
{
	NOT_USED(syscall_id);
	NOT_USED(arg1);
	return syscall();
}
pok_ret_t pok_syscall2  (pok_syscall_id_t syscall_id,
						uint32_t arg1,
						uint32_t arg2)
{
	NOT_USED(syscall_id);
	NOT_USED(arg1);	
	NOT_USED(arg2);
	return syscall();
}
pok_ret_t pok_syscall3 (pok_syscall_id_t syscall_id,
						uint32_t arg1,
						uint32_t arg2,
						uint32_t arg3)
{
	NOT_USED(syscall_id);
	NOT_USED(arg1);	
	NOT_USED(arg2);
	NOT_USED(arg3);	
	return syscall();
}
pok_ret_t pok_syscall4 (pok_syscall_id_t syscall_id,
						uint32_t arg1,
						uint32_t arg2,
						uint32_t arg3,
						uint32_t arg4)
{
	NOT_USED(syscall_id);
	NOT_USED(arg1);	
	NOT_USED(arg2);
	NOT_USED(arg3);	
	NOT_USED(arg4);		
	return syscall();
}
pok_ret_t pok_syscall5 (pok_syscall_id_t syscall_id,
						uint32_t arg1,
						uint32_t arg2,
						uint32_t arg3,
						uint32_t arg4,
						uint32_t arg5)
{
	NOT_USED(syscall_id);
	NOT_USED(arg1);	
	NOT_USED(arg2);
	NOT_USED(arg3);	
	NOT_USED(arg4);	
	NOT_USED(arg5);	
	return syscall();
}
pok_ret_t pok_syscall6 (pok_syscall_id_t syscall_id,
						uint32_t arg1,
						uint32_t arg2,
						uint32_t arg3,
						uint32_t arg4,
						uint32_t arg5,
						uint32_t arg6)
{
	NOT_USED(syscall_id);
	NOT_USED(arg1);	
	NOT_USED(arg2);
	NOT_USED(arg3);	
	NOT_USED(arg4);	
	NOT_USED(arg5);		
	NOT_USED(arg6);
	return syscall();
}
pok_ret_t pok_syscall7 (pok_syscall_id_t  syscall_id,
						uint32_t arg1,
						uint32_t arg2,
						uint32_t arg3,
						uint32_t arg4,
						uint32_t arg5,
						uint32_t arg6,
						uint32_t arg7)
{
	NOT_USED(syscall_id);
	NOT_USED(arg1);	
	NOT_USED(arg2);
	NOT_USED(arg3);	
	NOT_USED(arg4);	
	NOT_USED(arg5);		
	NOT_USED(arg6);	
	NOT_USED(arg7);
	return syscall();
}
\end{lstlisting}
\section{Context Switch}\label{sec:context switch}
Patmos context switching can be interrupt-driven: \os~configures the real-time clock interrupt interval to expire at specified points where scheduling decisions have to be taken and the current executing thread's context has to be switched, for example when a time slice ends and another partition has to execute.\\ A context switch can be also caused by the run-to-completion semantics: when a periodic thread ends its period or when a sporadic thread waits for an event to be ``up''.
\subsection{Interrupt-driven Context Switching}
When an interval interrupt is raised the control flow jumps to an interval interrupt service routine. The ISR defined by the operating system whose role is to perform the context switch is called \texttt{\_interval\_ISR} and is shown in listing \ref{lst:_interval_ISR}.\\ The Patmos RTC was presented in Section \ref{sec:interrupts}: one of its memory mapped registers allows to set the address of the interval ISR. When the system boots the operating system's entry point (in listing \ref{lst:OS entry point}) calls the booting function \texttt{pok\_boot} responsible for configuring the system before starting user's applications. \texttt{pok\_boot} initializes the underlying hardware through the function \texttt{pok\_arch\_init} which uses the function \texttt{\_\_PATMOS\_RTC\_WR\_ISR} to set the address of the ISR.\\

The modified \os maintains a pointer to the current executing thread's context, \texttt{current\_context}, which is used to save the current thread's status. After performing scheduling decisions \texttt{current\_context} points to the thread elected for execution (possibly the same), so it can be used to restore the elected thread's context.

\begin{lstlisting}[language=C, caption=Function \texttt{\_interval\_ISR}: the interval interrupt service routine, label=lst:_interval_ISR]
		.globl 		_interval_ISR
		.type 		_interval_ISR,@function
		.size 		_interval_ISR, .Ltmp3-_interval_ISR
		.fstart		_interval_ISR, .Ltmp3-_interval_ISR, 4
_interval_ISR:
		and 	$r0				    = $r0, 0x0

		sub		$r29			    = $r29, 4
		swm		[$r29 + 0]	  = $r1
		li		$r1				    = pok_current_context
		lwc		$r1 			    = [$r1 + 0]	
		
		swm  	[$r1 + 1] 		= $r2
		swm  	[$r1 + 2] 		= $r3
		swm  	[$r1 + 3] 		= $r4
		swm  	[$r1 + 4] 		= $r5
		swm  	[$r1 + 5] 		= $r6
		swm  	[$r1 + 6] 		= $r7
		swm  	[$r1 + 7] 		= $r8
		swm  	[$r1 + 8] 		= $r9
 		swm  	[$r1 + 9] 		= $r10
		swm  	[$r1 + 10] 		= $r11
		swm  	[$r1 + 11] 		= $r12
		swm  	[$r1 + 12] 		= $r13
		swm  	[$r1 + 13] 		= $r14
		swm  	[$r1 + 14] 		= $r15
		swm  	[$r1 + 15] 		= $r16
		swm  	[$r1 + 16] 		= $r17
		swm  	[$r1 + 17] 		= $r18
		swm  	[$r1 + 18] 		= $r19
		swm  	[$r1 + 19] 		= $r20
		swm  	[$r1 + 20] 		= $r21
		swm  	[$r1 + 21]		= $r22
		swm  	[$r1 + 22] 		= $r23
		swm  	[$r1 + 23] 		= $r24
		swm  	[$r1 + 24] 		= $r25
		swm  	[$r1 + 25] 		= $r26
		swm  	[$r1 + 26] 		= $r27
		swm  	[$r1 + 27] 		= $r28

		add		$r29			    = $r29, 4
		swm  	[$r1 + 28] 		= $r29
		swm  	[$r1 + 29] 		= $r30
		swm  	[$r1 + 30] 		= $r31

		mfs	 	$r5 			    = $s5
		mfs	 	$r6 			    = $s6
 		sub   $r2 		      = $r5, $r6
 		sspill $r2
 		swm   [$r1 + 47] 		= $r2

		mfs	 	$r2 			    = $s0
		swm  	[$r1 + 31] 		= $r2
		mfs		$r2 			    = $s1
		swm  	[$r1 + 32] 		= $r2
		mfs	 	$r2 			    = $s2
		swm  	[$r1 + 33] 		= $r2
		mfs	 	$r2 			    = $s3
		swm  	[$r1 + 34] 		= $r2
		mfs	 	$r2 			    = $s4
		swm  	[$r1 + 35] 		= $r2
		mfs	 	$r2 			    = $s5
		swm  	[$r1 + 36] 		= $r2
		mfs	 	$r2 			    = $s6
		swm  	[$r1 + 37] 		= $r2
		mfs	 	$r2 			    = $s7
		swm  	[$r1 + 38] 		= $r2
		mfs	 	$r2 			    = $s8
		swm  	[$r1 + 39] 		= $r2
		mfs	 	$r2 			    = $s9
		swm  	[$r1 + 40] 		= $r2
		mfs	 	$r2 			    = $s10
		swm  	[$r1 + 41] 		= $r2
		mfs	 	$r2 			    = $s11
		swm  	[$r1 + 42] 		= $r2
		mfs	 	$r2 			    = $s12
		swm  	[$r1 + 43] 		= $r2
		mfs	 	$r2 			    = $s13
		swm  	[$r1 + 44] 		= $r2
		mfs	 	$r2 			    = $s14
		swm  	[$r1 + 45] 		= $r2
		mfs	 	$r2 			    = $s15

		sub		$r29			    = $r29, 4
		lwc	 	$r2 			    = [$r29 + 0]
		add		$r29			    = $r29, 4
		swm  	[$r1 + 0] 		= $r2

		li		$r29 			    = pok_stack_end 
		mts 	$s6				    = $r29
		mts 	$s5			    	= $r29
		li		$r29 			    = pok_shadow_stack_end

		li		$r30 				  = _interval_ISR
		call 	pok_arch_decr_int
		nop
		nop
		nop

		brcf 	restore_context
		nop
		nop
		nop

.Ltmp3:
\end{lstlisting}

\texttt{\_interval\_ISR} is an assembly routine performing the following operations:

\setlength{\aboverulesep}{0pt}
\setlength{\belowrulesep}{0pt}
\setlength{\extrarowheight}{.75ex}
\newcolumntype{g}{>{\columncolor{light-gray}}l}
\begin{longtable}{g p{9cm}}
\toprule
\textbf{Line 6} & \texttt{r0} is assured to be set to 0\\
\midrule
\textbf{Lines 8-11} & To bootstrap the context switch a register has to be freed in order to hold the \texttt{current\_context} value. The shadow stack is used to hold the value of register \texttt{r1} and then the value of \texttt{current\_context}'s pointer is loaded into \texttt{r0}\\
\midrule
\textbf{Lines 12-39} & General purpose registers from \texttt{r2} to \texttt{r28} are saved starting from the next word pointed by \texttt{current\_context} according to the structure of \texttt{context\_t} presented in Section \ref{sec:thread context}\\
\midrule
\textbf{Lines 41-44} & \texttt{r29} is reset to its original value (after having stored \texttt{r1} value) and is stored to the correct memory locations pointed by \texttt{current\_context}\\
\midrule
\textbf{Lines 46-50} & The size of the thread's stack stored in the cache (and not consistent with the main memory, as explained in Section \ref{sec:stack cache}) is computed by subtracting to the stack cache spill address the stack pointer. This value is used to spill all the cached stack to the main memory. The size of the spilled stack is then saved in the right position in the context structure pointed by \texttt{current\_context}\\ 
\midrule
\textbf{Lines 52-82} & For each special register from \texttt{s0} to \texttt{s15} its content is saved to \texttt{r2} and then saved to the context pointer by \texttt{current\_context}\\
\midrule
\textbf{Lines 84-87} & The content of \textbf{r2}, previously stored on the shadow stack, is retrieved and saved in the context; then the original value of the shadow stack pointer (\texttt{r29}) is restored\\
\midrule
\textbf{Lines 89-92} & In order to prepare the execution of the kernel, the kernel's stack pointer is loaded into registers \texttt{r5} and \texttt{r6} and kernel's shadow stack pointer is loaded into register \texttt{r29}\\
\midrule
\textbf{Lines 94-98} & The function \texttt{pok\_arch\_decr\_int} is called\\
\midrule
\textbf{Lines 100-103} & A branch is performed to \texttt{restore\_context}\\
\bottomrule
\end{longtable}

The control flow started by an interval interrupt is depicted in figure \ref{fig:context switch flow}.
\begin{itemize}
  \item \texttt{\_interval\_ISR}: saves registers to \texttt{current\_context} and switches to kernel stack and kernel stack cache
  \item \texttt{pok\_arch\_decr\_int}: sets the next timer interval and calls the scheduler
  \item \texttt{pok\_sched}: performs scheduling decisions and updates \texttt{current\_context} to make it point to the context of the thread elected for execution
  \item \texttt{restore\_context}: registers are restored from \texttt{current\_context} and the function returns from the interrupt
\end{itemize}

	\begin{figure}[!ht]
		\begin{center}
		\makebox[\linewidth]{\includegraphics[scale=0.9]{figures/context_switch_flow.pdf}}
		\end{center}
		\caption{Flow of function calls needed to perform a context switch}
		\label{fig:context switch flow}
	\end{figure}

\begin{lstlisting}[language=C, caption=Function \texttt{restore\_context} restores context of the new selected thread, label=lst:restore_context]
 		.globl 		restore_context
		.type 		restore_context,@function
		.size 		restore_context, .Ltmp3-restore_context
		.fstart		restore_context, .Ltmp3-restore_context, 4
restore_context:
		and 	$r0				= $r0, 0x0

		li		$r1				= pok_current_context
		lwc		$r1 			= [$r1 + 0]

		lwc  	$r3 			= [$r1 + 2]
		lwc  	$r4 			= [$r1 + 3]
		lwc  	$r5 			= [$r1 + 4]
		lwc  	$r6 			= [$r1 + 5]
		lwc  	$r7 			= [$r1 + 6]
		lwc  	$r8 			= [$r1 + 7]
		lwc  	$r9 			= [$r1 + 8]
 		lwc  	$r10 			= [$r1 + 9]
		lwc  	$r11 			= [$r1 + 10]
		lwc  	$r12			= [$r1 + 11]
		lwc  	$r13 			= [$r1 + 12]
		lwc  	$r14 			= [$r1 + 13]
		lwc  	$r15 			= [$r1 + 14]
		lwc  	$r16 			= [$r1 + 15]
		lwc  	$r17 			= [$r1 + 16]
		lwc  	$r18 			= [$r1 + 17]
		lwc  	$r19 			= [$r1 + 18]
		lwc  	$r20 			= [$r1 + 19]
		lwc  	$r21 			= [$r1 + 20]
		lwc  	$r22 			= [$r1 + 21]
		lwc  	$r23 			= [$r1 + 22]
		lwc  	$r24 			= [$r1 + 23]
		lwc  	$r25 			= [$r1 + 24]
		lwc  	$r26 			= [$r1 + 25]
		lwc  	$r27 			= [$r1 + 26]
		lwc  	$r28 			= [$r1 + 27]
		lwc  	$r29 			= [$r1 + 28]
		lwc  	$r30 			= [$r1 + 29]
		lwc  	$r31 			= [$r1 + 30]

		lwm   $r2       = [$r1 + 47]
 		sens  $r2

		lwc  	$r2 			= [$r1 + 31]
		mts  	$s0 			= $r2
		lwc  	$r2 			= [$r1 + 32]
		mts  	$s1 			= $r2
		lwc  	$r2 			= [$r1 + 33]
		mts  	$s2 			= $r2
		lwc  	$r2 			= [$r1 + 34]
		mts  	$s3 			= $r2
		lwc  	$r2 			= [$r1 + 35]
		mts  	$s4 			= $r2
		lwc  	$r2 			= [$r1 + 36]
		mts  	$s5 			= $r2
		lwc  	$r2 			= [$r1 + 37]
		mts  	$s6 			= $r2
		lwc  	$r2 			= [$r1 + 38]
		mts  	$s7 			= $r2
		lwc  	$r2 			= [$r1 + 39]
		mts  	$s8 			= $r2
		lwc  	$r2 			= [$r1 + 41]
		mts  	$s10 			= $r2
		lwc  	$r2 			= [$r1 + 42]
		mts  	$s11 			= $r2
		lwc  	$r2 			= [$r1 + 43]
		mts  	$s12 			= $r2
		lwc  	$r2 			= [$r1 + 44]
		mts  	$s13 			= $r2
		lwc  	$r2 			= [$r1 + 45]
		mts  	$s14 			= $r2
		lwc  	$r2 			= [$r1 + 46]
		mts  	$s15 			= $r2

		lwc  	$r2 			= [$r1 + 40]
		mts  	$s9 			= $r2

		brcf	$r2
		lwc  	$r2 			= [$r1 + 1]
		lwc  	$r1 			= [$r1 + 0]
		nop		

.Ltmp3:
\end{lstlisting}

\texttt{restore\_context} function, shown in listing \ref{lst:restore_context}, performs the following operations:

\setlength{\aboverulesep}{0pt}
\setlength{\belowrulesep}{0pt}
\setlength{\extrarowheight}{.75ex}
\newcolumntype{g}{>{\columncolor{light-gray}}l}
\begin{longtable}{g p{9cm}}
\toprule
\textbf{Line 6} & \texttt{r0} is assured to be set to 0\\
\midrule
\textbf{Line 8-9} & \texttt{current\_context} pointer value is loaded into register \texttt{r1}\\
\midrule
\textbf{Lines 11-39} & All the general purpose registers are restored from the context pointed by \texttt{current\_context}\\
\midrule
\textbf{Lines 41-42} & The size of the stack previously hold in the cache is loaded from the context into \texttt{r2}, \texttt{r2} is then used to restore the stack into the cache though the \texttt{ensure} instruction\\
\midrule
\textbf{Lines 44-73} & For each special register from \texttt{s0} to \texttt{s15} its content is loaded from the context into \texttt{r2} and then restored\\
\midrule
\textbf{Lines 75-76} & As stated in Section \ref{sec:interrupts}, when an interval interrupt happens the current program counter is stored into register \texttt{s9} and represents the address to which the control has to return after the interrupt handling. So the previous content of \texttt{s9} loaded into \texttt{r2} and restored\\
\midrule
\textbf{Lines 78-81} & The control flow jumps to the location pointed by \texttt{r2} (return address of the interrupt) and finally \texttt{r2} and \texttt{r1} are restored\\
\bottomrule
\end{longtable}

% it starts after a timer interrupt. An ISR named \texttt{\_interval\_ISR} is called when a timer interrupt happens. The flow of function calls in figure \ref{fig:contextswitch} is then started.
\subsection{Explicit Context Switching}

As previously stated a context switch is explicitly requested when the period of a periodic task ends or when a sporadic task waits for an event. In this cases the \texttt{pok\_context\_switch} function is explicitly called. This function is called after a scheduling decision is taken and takes as a parameter the address of the context of the previously executing thread. \texttt{pok\_context\_switch} code is shown in listing \ref{lst:context_switch}.

\begin{lstlisting}[language=C, caption=Function \texttt{context\_switch}: saves the context to the location pointed by \texttt{r3}, label=lst:context_switch]
 		.globl 		pok_context_switch
		.type 		pok_context_switch,@function
		.size 		pok_context_switch, .Ltmp6-pok_context_switch
		.fstart		pok_context_switch, .Ltmp6-pok_context_switch, 4
pok_context_switch:
		and 	$r0				    = $r0, 0x0
	
		swm  	[$r3 + 0] 		= $r1
		swm  	[$r3 + 1] 		= $r2
		swm  	[$r3 + 2] 		= $r3
		swm  	[$r3 + 3] 		= $r4
		swm  	[$r3 + 4] 		= $r5
		swm  	[$r3 + 5] 		= $r6
		swm  	[$r3 + 6] 		= $r7
		swm  	[$r3 + 7] 		= $r8
		swm  	[$r3 + 8] 		= $r9
  	swm  	[$r3 + 9] 		= $r10
		swm  	[$r3 + 10] 		= $r11
		swm  	[$r3 + 11] 		= $r12
		swm  	[$r3 + 12] 		= $r13
		swm  	[$r3 + 13] 		= $r14
		swm  	[$r3 + 14] 		= $r15
		swm  	[$r3 + 15] 		= $r16
		swm  	[$r3 + 16] 		= $r17
		swm  	[$r3 + 17] 		= $r18
		swm  	[$r3 + 18] 		= $r19
		swm  	[$r3 + 19] 		= $r20
		swm  	[$r3 + 20] 		= $r21
		swm  	[$r3 + 21]		= $r22
		swm  	[$r3 + 22] 		= $r23
		swm  	[$r3 + 23] 		= $r24
		swm  	[$r3 + 24] 		= $r25
		swm  	[$r3 + 25] 		= $r26
		swm  	[$r3 + 26] 		= $r27
		swm  	[$r3 + 27] 		= $r28
		swm  	[$r3 + 28] 		= $r29
		swm  	[$r3 + 29] 		= $r30
		swm  	[$r3 + 30] 		= $r31

		mfs	 	$r5 	  		  = $s5
		mfs	 	$r6 	  		  = $s6
  	sub   $r2 	        = $r5, $r6
  	sspill $r2
  	swm   [$r3 + 47]    = $r2

		add 	$r2 			    = $r30, $r31
		mts 	$s9 			    = $r2

		mfs	 	$r2 			    = $s0
		swm  	[$r3 + 31] 		= $r2
		mfs		$r2 			    = $s1
		swm  	[$r3 + 32] 		= $r2
		mfs	 	$r2 			    = $s2
		swm  	[$r3 + 33] 		= $r2
		mfs	 	$r2 			    = $s3
		swm  	[$r3 + 34] 		= $r2
		mfs	 	$r2 			    = $s4
		swm  	[$r3 + 35] 		= $r2
		mfs	 	$r2 			    = $s5
		swm  	[$r3 + 36] 		= $r2
		mfs	 	$r2 			    = $s6
		swm  	[$r3 + 37] 		= $r2
		mfs	 	$r2 			    = $s7
		swm  	[$r3 + 38] 		= $r2
		mfs	 	$r2 			    = $s8
		swm  	[$r3 + 39] 		= $r2

		mfs	 	$r2 			    = $s9
		swm  	[$r3 + 40] 		= $r2
		mfs	 	$r2 			    = $s10
		swm  	[$r3 + 41] 		= $r2
		mfs	 	$r2 			    = $s11
		swm  	[$r3 + 42] 		= $r2
		mfs	 	$r2 			    = $s12
		swm  	[$r3 + 43] 		= $r2
		mfs	 	$r2 			    = $s13
		swm  	[$r3 + 44] 		= $r2
		mfs	 	$r2 			    = $s14
		swm  	[$r3 + 45] 		= $r2
		mfs	 	$r2 			    = $s15
		swm  	[$r3 + 46] 		= $r2

		brcf 	restore_context
		nop
		nop
		nop
.Ltmp6:
\end{lstlisting}

\texttt{pok\_context\_switch}, just like the interval ISR, saves the current context to the location pointed by \texttt{r3} register (which holds the function's argument). In order to restore the context later the return address, hold in \texttt{r30} and \texttt{r31}, has to be saved into \texttt{s9} (lines 46-47). The context of the thread elected for execution is pointed by \texttt{current\_context} and restored by the function \texttt{restore\_context}.
