@article{SayiamR.Sahingoz2014,
abstract = {Process mining is a relatively new and emerging research area dealing with the process modeling and process analysis by studying on the event logs. By mining these logs, one can understand what is actually happening in the organization, which will bring quite different results than what people think. That is the reason why big organizations start using process mining to x-ray their organizations by various industrial and scientific process mining applications. This study aims to enlighten the researchers about the details of process mining and ProM framework. To accomplish this, firstly, the details and the conversion process of MXML format, which is the correct format applicable for ProM tool, are explained. After that, some main process mining algorithms are detailed by analyzing Alpha Algorithm, Heuristic Mining Algorithm and Social Network Algorithm. Finally, how to extract data through Software Development cycle process is presented, and the results, which are obtained by analyzing the related data, are depicted.},
author = {{Sayiam, R., Sahingoz}, O. K.},
file = {:Users/ConnieZalo/Desktop/Thesis/papers/Papers2/WCE2014{\_}pp407-411.pdf:pdf},
isbn = {9789881925275},
issn = {20780958},
journal = {World Congress on Engineering and Computer Science},
keywords = {Conversion process,Data collection,Data mining,Development,Heuristic algorithms,PROM,Softw,Software design},
pages = {407--411},
title = {{A process mining approach in Software Development and Testing Process: A case study}},
volume = {1},
year = {2014}
}
@article{Damevski2017,
abstract = {In this paper, we present a semi-automatic approach for mining a$\backslash$nlarge-scale dataset of IDE interactions to extract usage smells, i.e.,$\backslash$ninefficient IDE usage patterns exhibited by developers in the field. The$\backslash$napproach outlined in this paper first mines frequent IDE usage patterns,$\backslash$nfiltered via a set of thresholds and by the authors, that are$\backslash$nsubsequently supported (or disputed) using a developer survey, in order$\backslash$nto form usage smells. In contrast with conventional mining of IDE usage$\backslash$ndata, our approach identifies time-ordered sequences of developer$\backslash$nactions that are exhibited by many developers in the field. This pattern$\backslash$nmining workflow is resilient to the ample noise present in IDE datasets$\backslash$ndue to the mix of actions and events that these datasets typically$\backslash$ncontain. We identify usage patterns and smells that contribute to the$\backslash$nunderstanding of the usability of Visual Studio for debugging, code$\backslash$nsearch, and active file navigation, and, more broadly, to the$\backslash$nunderstanding of developer behavior during these software development$\backslash$nactivities. Among our findings is the discovery that developers are$\backslash$nreluctant to use conditional breakpoints when debugging, due to$\backslash$nperceived IDE performance problems as well as due to the lack of error$\backslash$nchecking in specifying the conditional.},
author = {Damevski, Kostadin and Shepherd, David C. and Schneider, Johannes and Pollock, Lori},
doi = {10.1109/TSE.2016.2592905},
file = {:Users/ConnieZalo/Desktop/Thesis/papers/Papers2/07516714.pdf:pdf},
isbn = {0098-5589},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {IDE usage data,data mining,pattern mining,usability analysis},
number = {4},
pages = {359--371},
title = {{Mining Sequences of Developer Interactions in Visual Studio for Usage Smells}},
volume = {43},
year = {2017}
}
@article{Minelli2016,
abstract = {—While coding, developers construct and maintain mental models of software systems to support the task at hand. Although source code is the main product of software devel-opment, the process involves navigating and inspecting entities beyond the ones that are edited by the end of a task. Developers use various user interfaces (UI) offered by the Integrated Devel-opment Environment (IDE) to navigate the complex, and often hidden, relationships between program entities. These UIs impose fixed navigation costs, in terms of the number of interactions that a developer is required to perform to reach an entity of interest. It is unclear to what extent the actual navigation effort differs from an ideal setting, and if there is any room for actual improvement. We present a preliminary empirical study, where we analyzed a corpus of IDE interaction data coming from 6 developers totaling more than 20 days of development activity. To measure the navigation efficiency, we compute a combination of different ideal settings and compare them against the observed navigation events. Our findings reveal that, on average, developers perform 1.5 to 19 times more navigation events than the ideal case. While different factors make the ideal setting unfeasible, we believe that this calls for novel approaches to support the navigation in integrated development environments.},
author = {Minelli, Roberto and Mocci, Andrea and Lanza, Michele},
doi = {10.1109/IWESEP.2016.11},
file = {:Users/ConnieZalo/Desktop/Thesis/papers/c14 - Measuring navigation efficiency in the IDE.pdf:pdf},
isbn = {9781509018512},
journal = {Proceedings - 7th International Workshop on Empirical Software Engineering in Practice, IWESEP 2016},
keywords = {efficiency,empirical study,ide,interaction data,navigation effort,productivity},
pages = {1--6},
title = {{Measuring Navigation Efficiency in the IDE}},
year = {2016}
}
@article{Minelli2014,
abstract = {Integrated Development Environments (IDEs) have become the de facto standard vehicle to develop software systems. The user interface (UI) of an IDE offers a staggering amount of facilities to manipulate source code, such as inspectors, debuggers, recommenders, alternative viewers, etc. It is unclear how developers use the UI of an IDE and whether such UIs actually give appropriate support to the developers. We present a visual approach to understand and characterize development sessions from the UI perspective. The tool supporting our approach mines and processes the finest-grained UI-level events making up development sessions and presents them visually. We have collected, visualized, and analyzed hundreds of development sessions and report on our findings.},
author = {Minelli, Roberto and Mocci, Andrea and Lanza, Michele and Baracchi, Lorenzo},
doi = {10.1109/VISSOFT.2014.31},
file = {:Users/ConnieZalo/Desktop/Thesis/papers/c4 - Visualizing Developer Interactions.pdf:pdf},
isbn = {9780769553054},
journal = {Proceedings - 2nd IEEE Working Conference on Software Visualization, VISSOFT 2014},
keywords = {IDE,comprehension,interaction,visual storytelling},
pages = {147--156},
title = {{Visualizing developer interactions}},
year = {2014}
}
@article{Minelli2016a,
abstract = {Integrated Development Environments (IDEs) lack effective support to browse complex relationships between source code elements. As a result, developers are often forced to exploit multiple user interface components at the same time, bringing the IDE into a complex, �chaotic� state. Keeping track of these relationships demands increased source code navigation and cognitive load, leading to productivity deficits documented in observational studies. Beyond small-scale studies, the amount and nature of the chaos experienced by developers in the wild is unclear, and more importantly it is unclear how to tame it. Based on a dataset of fine-grained interaction data, we propose several metrics to characterize and quantify the �level of chaos� of an IDE. Our results suggest that developers spend, on average, more than 30{\%} of their time in a chaotic environment, and that this may affect their productivity. To support developers, we devise and evaluate simple strategies that automatically alter the UI of the IDE. We find that even simple strategies may considerably reduce the level of chaos both in terms of effective space occupancy and time spent in a chaotic environment.},
author = {Minelli, Roberto and Mocci, Andrea and Robbes, Romain and Lanza, Michele},
doi = {10.1109/ICPC.2016.7503714},
file = {:Users/ConnieZalo/Desktop/Thesis/papers/c16 - Taming the IDE with fine-grained interaction data .pdf:pdf},
isbn = {9781509014286},
journal = {IEEE International Conference on Program Comprehension},
number = {Dcc},
pages = {1--10},
title = {{Taming the IDE with fine-grained interaction data}},
volume = {2016-July},
year = {2016}
}
@article{Minelli2016b,
abstract = {As part of their daily work, developers interact with Integrated Development Environments (IDE), generating thousands of events. Together with other aspects of development, this data also captures the modus operandi of the developer, including all the program entities she interacted with during a development session. This "working set" (or context) is leveraged by developers to create and maintain their mental model of the software system at hand. Understanding how developers navigate and interact with source code during a development session is an open question. We present a novel visual approach to understand how working sets evolve during a development session. The visualization incrementally depicts all the program entities involved in a development session, the intensity of the developer activity on them, and the navigation paths that occurred between them. We visualized about a thousand development sessions, and categorized them according to their visual properties.},
author = {Minelli, Roberto and Mocci, Andrea and Lanza, Michele},
doi = {10.1109/VISSOFT.2016.5},
file = {:Users/ConnieZalo/Desktop/Thesis/papers/c15 - Visualizing the evolution of working sets.pdf:pdf},
isbn = {9781509038503},
journal = {Proceedings - 2016 IEEE Working Conference on Software Visualization, VISSOFT 2016},
keywords = {Development session,Dflow,Ide,Interaction data,Mental model,Visual,Visualization,Working set},
pages = {141--150},
title = {{Visualizing the Evolution of Working Sets}},
year = {2016}
}
@article{Minelli2013,
abstract = {Developers use the Integrated Development Environment (IDE) to develop a system at hand, by reading, understanding, and writing its source code. They do so by exploiting the tools and facilities provided by the IDE. This also allows them to build a mental model of the system to perform informed changes. It is however not clear how and when developers use which facility and tool, and to what extent the current services offered by the IDE appropriately support the navigation. We present an approach to visualize the activities of developers within the IDE, implemented in a tool: DFLow. DFLOW records all IDE interactions that occur during a development session and visualizes them through a web-based visualization platform.},
author = {Minelli, Roberto and Lanza, Michele},
doi = {10.1109/VISSOFT.2013.6650531},
file = {:Users/ConnieZalo/Desktop/Thesis/papers/Papers2/Mine2013d.pdf:pdf},
isbn = {9781479914579},
journal = {2013 1st IEEE Working Conference on Software Visualization - Proceedings of VISSOFT 2013},
pages = {2--5},
title = {{Visualizing the workflow of developers}},
year = {2013}
}
@article{Rubin2014,
abstract = {Modern information systems produce tremendous amounts of event data. The area of process mining deals with extracting knowledge from this data. Real-life processes can be effectively discovered, analyzed and optimized with the help of mature process mining techniques. There is a variety of process mining case studies and experience reports from such business areas as healthcare, public, transportation and education. Although nowadays, these techniques are mostly used for discovering business processes. The goal of this industrial paper is to show that process mining can be applied to software too. Here we present and analyze our experiences on applying process mining in different productive software systems used in the touristic domain. Process models and user interface workflows underlie the functional specifications of the systems we experiment with. When the systems are utilized, user interaction is recorded in event logs. After applying process mining methods to these logs, process and user interface flow models are automatically derived. These resulting models provide insight regarding the real usage of the software, motivate the changes in the functional specifications, enable usability improvements and software redesign. Thus, with the help of our examples we demonstrate that process mining facilitates new forms of software analysis. The user interaction with almost every software system can be mined in order to improve the software and to monitor and measure its real usage.},
author = {Rubin, Vladimir A. and Mitsyuk, Alexey A. and Lomazova, Irina A. and van der Aalst, Wil M. P.},
doi = {10.1145/2652524.2652583},
file = {:Users/ConnieZalo/Desktop/Thesis/papers/Papers2/pm1 - Process Mining Can be applied to software too.pdf:pdf},
isbn = {9781450327749},
issn = {19493770},
journal = {Proceedings of the 8th ACM/IEEE International Symposium on Empirical Software Engineering and Measurement - ESEM '14},
keywords = {client technology,design,process mining,software process mining,user interface},
pages = {1--8},
title = {{Process mining can be applied to software too!}},
url = {http://dl.acm.org/citation.cfm?doid=2652524.2652583},
year = {2014}
}
@article{,
file = {:Users/ConnieZalo/Desktop/Thesis/papers/Contextual Factors.pdf:pdf},
title = {{No Title}}
}
@article{Snipes2015,
abstract = {Integrated development environments such as Eclipse and Visual Studio provide tools and capabilities to perform tasks such as navigating among classes and methods, continuous compilation, code refactoring, automated testing, and integrated debugging, all designed to increase productivity. Instrumenting the integrated development environment to collect usage data provides a more fine-grained understanding of developers' work than was previously possible. Usage data supports analysis of how developers spend their time, what activities might benefit from greater tool support, where developers have difficulty comprehending code, and whether they are following specific practices such as test-driven development. With usage data, we expect to uncover more nuggets of how developers create mental models, how they investigate code, how they perform mini trial-and-error experiments, and what might drive productivity improvements for everyone.},
author = {Snipes, Will and Murphy-Hill, Emerson and Fritz, Thomas and Vakilian, Mohsen and Damevski, Kostadin and Nair, Anil R. and Shepherd, David},
doi = {10.1016/B978-0-12-411519-4.00005-7},
file = {:Users/ConnieZalo/Desktop/Thesis/papers/A Practical Guide to Analyzing IDE Usage Data.pdf:pdf},
isbn = {9780124115439},
journal = {The Art and Science of Analyzing Software Data},
keywords = {Developer Activity,Productivity,Refactoring,Usage Data},
pages = {85--138},
title = {{A Practical Guide to Analyzing IDE Usage Data}},
year = {2015}
}
@article{Yoon2011,
abstract = {In this paper, we present FLUORITE, a publicly available event logging plug-in for Eclipse which captures all of the low-level events when using the Eclipse code editor. FLUORITE captures not only what types of events occurred in the code editor, but also more detailed information such as the inserted and deleted text and the specific parameters for each command. This enables the detection of many usage patterns that could otherwise not be recognized, such as "typo correction" that requires knowing that the entered text is immediately deleted and replaced. Moreover, the snapshots of each source code file that has been opened during the session can be completely reproduced using the collected information. We also provide analysis and visualization tools which report various statistics about usage patterns, and we provide the logs in an XML format so others can write their own analyzers. FLUORITE can be used for not only evaluating existing tools, but also for discovering issues that motivate new tools.},
author = {Yoon, YoungSeok and Myers, Brad a.},
doi = {10.1145/2089155.2089163},
file = {:Users/ConnieZalo/Desktop/Thesis/papers/fluorite{\_}1.pdf:pdf},
isbn = {9781450310246},
journal = {Proceedings of the 3rd ACM SIGPLAN workshop on Evaluation and usability of programming languages and tools - PLATEAU '11},
keywords = {code editor,editing strategies,event logger},
pages = {25},
title = {{Capturing and analyzing low-level events from the code editor}},
url = {http://dl.acm.org.prox.lib.ncsu.edu/citation.cfm?id=2089155.2089163},
year = {2011}
}
@article{Gasparic2017,
abstract = {Context, as modeled through variables called contextual factors, can improve human-computer interaction. To date, in applications supporting software development, such as integrated development environments (IDEs) and recommendation systems for software engineering (RSSEs), contextual factors have generally been constrained to project artifacts, such as source code. In this paper, we present a context model that includes thirteen contextual factors, which capture various situations in which developers interact with an IDE. This context model can be used to support and enhance user interaction with an IDE or to improve the accuracy and timing of recommendations produced by RSSEs. To assess whether the proposed contextual factors are informative for a context model, we statistically evaluated the correlations between IDE command usage and different situations, as they are described by the factors. If a contextual factor correlates with the usage of a command this means that the user is using the command differently when the values of the contextual factor change. We discovered that different factors correlate with different commands and that all the factors correlate with some commands, hence, when a context change is detected, we can also expect a change in the interaction with an IDE.},
author = {Gasparic, Marko and Murphy, Gail C. and Ricci, Francesco},
doi = {10.1016/j.jss.2016.09.012},
file = {:Users/ConnieZalo/Desktop/Thesis/papers/r1 - A context model for IDE-based recommendation systems.pdf:pdf},
issn = {01641212},
journal = {Journal of Systems and Software},
keywords = {Commands,Context,Integrated development environment,Recommendation systems for software engineering,Software development,Usage},
pages = {200--219},
publisher = {Elsevier Inc.},
title = {{A context model for IDE-based recommendation systems}},
volume = {128},
year = {2017}
}
@article{Minelli2015,
abstract = {—Developing software is a complex mental activity, requiring extensive technical knowledge and abstraction capa-bilities. The tangible part of development is the use of tools to read, inspect, edit, and manipulate source code, usually through an IDE (integrated development environment). Common claims about software development include that program comprehension takes up half of the time of a developer, or that certain UI (user interface) paradigms of IDEs offer insufficient support to developers. Such claims are often based on anecdotal evidence, throwing up the question of whether they can be corroborated on more solid grounds. We present an in-depth analysis of how developers spend their time, based on a fine-grained IDE interaction dataset consisting of ca. 740 development sessions by 18 developers, amounting to 200 hours of development time and 5 million of IDE events. We propose an inference model of development activities to precisely measure the time spent in editing, navigating and searching for artifacts, interacting with the UI of the IDE, and performing corollary activities, such as inspection and debugging. We report several interesting findings which in part confirm and reinforce some common claims, but also disconfirm other beliefs about software development.},
author = {Minelli, Roberto and Mocci, Andrea and Lanza, Michele},
doi = {10.1109/ICPC.2015.12},
file = {:Users/ConnieZalo/Desktop/Thesis/papers/c10 - I know what you did last summer.pdf:pdf},
isbn = {9781467381598},
issn = {1092-8138},
journal = {IEEE International Conference on Program Comprehension},
keywords = {empirical study,interaction data,program understanding,user interface},
pages = {25--35},
title = {{I Know What You Did Last Summer - An Investigation of How Developers Spend Their Time}},
volume = {2015-Augus},
year = {2015}
}
@article{Minelli2014a,
abstract = {Integrated Development Environments (IDEs) have become the de facto standard vehicle to develop software systems. The user interface (UI) of an IDE offers a staggering amount of facilities to manipulate source code, such as inspectors, debuggers, recommenders, alternative viewers, etc. It is unclear how developers use the UI of an IDE and whether such UIs actually give appropriate support to the developers. We present a visual approach to understand and characterize development sessions from the UI perspective. The tool supporting our approach mines and processes the finest-grained UI-level events making up development sessions and presents them visually. We have collected, visualized, and analyzed hundreds of development sessions and report on our findings.},
author = {Minelli, Roberto and Mocci, Andrea and Lanza, Michele and Baracchi, Lorenzo},
doi = {10.1109/VISSOFT.2014.31},
file = {:Users/ConnieZalo/Desktop/Thesis/papers/Visualising developer interactions.pdf:pdf},
isbn = {9780769553054},
journal = {Proceedings - 2nd IEEE Working Conference on Software Visualization, VISSOFT 2014},
keywords = {IDE,comprehension,interaction,visual storytelling},
pages = {147--156},
title = {{Visualizing developer interactions}},
year = {2014}
}
@article{Robbes2008,
abstract = {Our research is driven by the motivation that change must be put in the center, if one wants to understand the complex processes of software evolution. We built a toolset named SpyWare which, using a monitoring plug-in for integrated development environments (IDEs), tracks the changes that a developer performs on a program as they happen. SpyWare stores these first-class changes in a change repository and offers a plethora of productivity-enhancing IDE extensions to exploit the recorded information.},
author = {Robbes, Romain and Lanza, Michele},
doi = {10.1145/1368088.1368219},
file = {:Users/ConnieZalo/Desktop/Thesis/papers/SpyWare - Eclipse.pdf:pdf},
isbn = {978-1-60558-079-1},
issn = {02705257},
journal = {Proceedings of the 30th International Conference on Software Engineering},
keywords = {change,modelling,program transformation,visualization},
pages = {847--850},
title = {{SpyWare: A Change-aware Development Toolset}},
url = {http://doi.acm.org/10.1145/1368088.1368219},
year = {2008}
}
@article{Minelli,
author = {Minelli, Roberto and Lanza, Michele},
file = {:Users/ConnieZalo/Desktop/Thesis/papers/02-DFlow-ESUG2013.pdf:pdf},
title = {{DFlow – A Platform to Profile Developers}}
}
@article{Carter2010,
abstract = {It would be useful if software engineers/instructors could be aware that remote team members/students are having difficulty with their programming tasks. We have developed an approach that tries to automatically create this semantic awareness based on developers' interactions with the programming environment, which is extended to log these interactions and allow the developers to train or supervise the algorithm by explicitly indicating they are having difficulty. Based on the logs of six programmers, we have found that our approach has high accuracy.},
author = {Carter, Jason and Dewan, Prasun},
doi = {10.1145/1718918.1718958},
file = {:Users/ConnieZalo/Desktop/Thesis/papers/p211-carter.pdf:pdf},
isbn = {9781605587950},
journal = {Proceedings of the 2010 ACM conference on Computer supported cooperative work - CSCW '10},
keywords = {context aware computing,help,machine learning},
pages = {211},
title = {{Are you having difficulty?}},
url = {http://portal.acm.org/citation.cfm?doid=1718918.1718958},
year = {2010}
}
@article{Minelli2013a,
abstract = {Developers use the Integrated Development Environment (IDE) to develop a system at hand, by reading, understanding, and writing its source code. They do so by exploiting the tools and facilities provided by the IDE. This also allows them to build a mental model of the system to perform informed changes. It is however not clear how and when developers use which facility and tool, and to what extent the current services offered by the IDE appropriately support the navigation. We present an approach to visualize the activities of developers within the IDE, implemented in a tool: DFLow. DFLOW records all IDE interactions that occur during a development session and visualizes them through a web-based visualization platform.},
author = {Minelli, Roberto and Lanza, Michele},
doi = {10.1109/VISSOFT.2013.6650531},
file = {:Users/ConnieZalo/Desktop/Thesis/papers/c1 - Visualizing the workflow of developers.pdf:pdf},
isbn = {9781479914579},
journal = {2013 1st IEEE Working Conference on Software Visualization - Proceedings of VISSOFT 2013},
pages = {2--5},
title = {{Visualizing the workflow of developers}},
year = {2013}
}
@article{Murphy-Hill2012,
abstract = {Software developers interact with the development environments they use by issuing commands that execute various programming tools, from source code formatters to build tools. However, developers often only use a small subset of the commands offered by modern development environments, reducing their overall development fluency. In this paper, we use several existing command recommender algorithms to suggest new commands to developers based on their existing command usage history, and also introduce several new algorithms. By running these algorithms on data submitted by several thousand Eclipse users, we describe two studies that explore the feasibility of automatically recommending commands to software developers. The results suggest that, while recommendation is more difficult in development environments than in other domains, it is still feasible to automatically recommend commands to developers based on their usage history, and that using patterns of past discovery is a useful way to do so.},
author = {Murphy-Hill, Emerson and Jiresal, Rahul and Murphy, Gail C.},
doi = {10.1145/2393596.2393645},
file = {:Users/ConnieZalo/Desktop/Thesis/papers/a42-murphy-hill.pdf:pdf},
isbn = {9781450316149},
journal = {Proceedings of the ACM SIGSOFT 20th International Symposium on the Foundations of Software Engineering - FSE '12},
keywords = {commands,discovery,ides,software developers},
pages = {1},
title = {{Improving software developers' fluency by recommending development environment commands}},
url = {http://dl.acm.org/citation.cfm?doid=2393596.2393645},
year = {2012}
}
@article{Hummel2008,
abstract = {For many years, the IT industry has sought to accelerate the software development process by assembling new applications from existing software assets. However, true component-based reuse of the form Douglas Mcllroy envisaged in the 1960s is still the exception rather than the rule, and most of the systematic software reuse practiced today uses heavyweight approaches such as product-line engineering or domain-specific frameworks. By component, we mean any cohesive and compact unit of software functionality with a well-defined interface - from simple programming language classes to more complex artifacts such as Web services and Enterprise JavaBeans.},
author = {Hummel, Oliver and Janjic, Werner and Atkinson, Colin},
doi = {10.1109/MS.2008.110},
file = {:Users/ConnieZalo/Desktop/Thesis/papers/CodeConjurer.pdf:pdf},
isbn = {0740-7459},
issn = {07407459},
journal = {IEEE Software},
keywords = {Component-based development,Eclipse plug-in,Engines,Java,Libraries,Open source software,Presses,Programming,Reuse recommendation,Search engines,Software,Software reuse,Software search engines,Test-driven search},
number = {5},
pages = {45--52},
pmid = {21058338},
title = {{Code conjurer: Pulling reusable software out of thin air}},
volume = {25},
year = {2008}
}
@article{Watson1996,
abstract = {The National Institute of Standards and Technology (NIST) has a unique responsibility for computer systems technology within the Federal government. NIST's Computer Systems Laboratory (CSL) develops standards and guidelines, provides technical assistance, and conducts research for computers and related telecommunications systems to achieve more effective utilization of Federal information technology resources. CSL's reponsibilities include development of technical, management, physical, and administrative standards and guidelines for the cost-effective security and privacy of sensitive unclassified information processed in federal computers. CSL assists agencies in developing security plans and in improving computer security awareness training. This Special Publication 500 series reports CSL research and guidelines to Federal agencies as well as to organizations in industry, gov-ernment, and academia. National Institute of Standards and Technology Special Publication 500-235 Natl. Inst. Stand. Technol. Spec. Publ. 500-235, 123 pages (September 1996) iii Abstract The purpose of this document is to describe the structured testing methodology for software testing, also known as basis path testing. Based on the cyclomatic complexity measure of McCabe, structured testing uses the control flow structure of software to establish path cover-age criteria. The resultant test sets provide more thorough testing than statement and branch coverage. Extensions of the fundamental structured testing techniques for integration testing and object-oriented systems are also presented. Several related software complexity metrics are described. Summaries of technical papers, case studies, and empirical results are presented in the appendices.},
author = {a.H. Watson and McCabe, T.J. and Wallace, D.R.},
doi = {800.638.6316},
file = {:Users/ConnieZalo/Desktop/Thesis/papers/Mc-cabe-metric.pdf:pdf},
issn = {00831883},
journal = {NIST Special Publication},
number = {235},
pages = {1--114},
title = {{Structured Testing: A Testing Methodology Using the Cyclomatic Complexity Metric}},
url = {http://idldoc.idldev.com/export/628/tags/IDLDOC{\_}3{\_}1{\_}1/idldoc/project/nist235r.pdf},
volume = {500},
year = {1996}
}
@article{Shaffer2015,
abstract = {What are software developers doing during a change task? While an answer to this question opens countless opportunities to support developers in their work, only little is known about developers' detailed navigation behavior for realistic change tasks. Most empirical studies on developers performing change tasks are limited to very small code snippets or are limited by the granularity or the detail of the data collected for the study. In our research, we try to overcome these limitations by combining user interaction monitoring with very fine granular eye-tracking data that is automatically linked to the underlying source code entities in the IDE. In a study with 12 professional and 10 student developers working on three change tasks from an open source system, we used our approach to investigate the detailed navigation of developers for realistic change tasks. The results of our study show, amongst others, that the eye tracking data does indeed capture different aspects than user interaction data and that developers focus on only small parts of methods that are often related by data flow. We discuss our findings and their implications for better developer tool support.},
author = {Shaffer, Timothy R. and Wise, Jenna L. and Walters, Braden M. and M{\"{u}}ller, Sebastian C. and Falcone, Michael and Sharif, Bonita},
doi = {10.1145/2786805.2803188},
file = {:Users/ConnieZalo/Desktop/Thesis/papers/itrace.pdf:pdf},
isbn = {9781450336758},
journal = {Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering - ESEC/FSE 2015},
keywords = {comprehension,eye-tracking,plugin,traceability},
pages = {954--957},
title = {{iTrace: enabling eye tracking on software artifacts within the IDE to support software engineering tasks}},
url = {http://dl.acm.org.prox.lib.ncsu.edu/citation.cfm?id=2786805.2803188},
year = {2015}
}
@article{Fogarty2005,
abstract = {The computer and communication systems that office workers currently use tend to interrupt at inappropriate times or unduly demand attention because they have no way to determine when an interruption is appropriate. Sensor-based statistical models of human interruptibility offer a potential solution to this problem. Prior work to examine such models has primarily reported results related to social engagement, but it seems that task engagement is also important. Using an approach developed in our prior work on sensor-based statistical models of human interruptibility, we examine task engagement by studying programmers working on a realistic programming task. After examining many potential sensors, we implement a system to log low-level input events in a development environment. We then automatically extract features from these low-level event logs and build a statistical model of interruptibility. By correctly identifying situations in which programmers are non-interruptible and minimizing cases where the model incorrectly estimates that a programmer is non-interruptible, we can support a reduction in costly interruptions while still allowing systems to convey notifications in a timely manner.},
author = {Fogarty, James and Ko, Andrew J. and Aung, Htet Htet and Golden, Elspeth and Tang, Karen P. and Hudson, Scott E.},
doi = {10.1145/1054972.1055018},
file = {:Users/ConnieZalo/Desktop/Thesis/papers/Ach{\_}1 - Fogarty.pdf:pdf},
isbn = {1581139985},
issn = {02749696},
journal = {Proceedings of the SIGCHI conference on Human factors in computing systems  - CHI '05},
pages = {331},
pmid = {1301},
title = {{Examining task engagement in sensor-based statistical models of human interruptibility}},
url = {http://portal.acm.org/citation.cfm?doid=1054972.1055018},
year = {2005}
}
